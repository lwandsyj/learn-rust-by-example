1. Rust 中只有一种字符串，但有多种方法来处理字符串的分配和对该字符串的引用。

4.1.1 字符串与字符串
让我们首先尝试澄清一些事情：首先，Rust 中确实有String2 个独立的核心字符串类型（和str）。虽然它们在技术上是不同的类型，但对于大多数意图和目的而言，它们是相同的东西。它们都表示任意长度的 UTF-8 字符序列，存储在连续的内存区域中。和之间唯一的实际区别是内存的管理方式。此外，为了理解所有核心 Rust 类型，从内存管理方式角度思考它们会很有帮助。因此，两种 Rust 字符串类型可以总结为：Stringstr

str：堆栈分配的UTF-8字符串，可以借用但不能移动或变异
String：堆分配的UTF-8字符串，可以借用和变异
在 C 和 C++ 等语言中，堆分配数据和堆栈分配数据之间的区别可能很模糊，因为 C 指针不会告诉您内存是如何分配的。最好的情况是，它们告诉您有一个特定类型的内存区域，该区域可能有效，并且长度可能为 0 到 N 个元素。在 Rust 中，内存分配是显式的，因此除了元素数量之外，类型本身通常还定义内存的分配方式。

在 C 中，您可以在堆栈上分配字符串并更改它们，但在 Rust 中，如果不使用关键字，则不允许这样做unsafe。毫不奇怪，这是 C 语言编程错误的主要来源。

让我们举例说明一些 C 字符串：

1
2
char *stack_string = "stack string";
char *heap_string  = strndup("heap string");
复制
在上面的代码中，我们有两个相同的指针类型，指向不同类型的内存。第一个stack_string是指向堆栈分配内存的指针。在堆栈上分配的内存通常由编译器处理，并且分配本质上是瞬时的。heap_string是相同类型的指针，指向堆分配的字符串。strndup()是一个标准 C 库函数，它使用 在堆上分配内存区域malloc()，将输入复制到该区域，并返回新分配区域的地址。

[笔记]  笔记
如果我们很迂腐，我们可能会说"heap string"上面最初是堆栈分配的，但在调用后转换为堆分配的字符串strndup()。您可以通过检查编译器生成的二进制文件来证明这一点，该二进制文件将包含二进制文件中的文字heap string。

现在，就 C 而言，所有字符串都是相同的：它们只是任意长度的连续内存区域，以空字符（十六进制字节值）结尾0x00。

因此，如果我们转回考虑 Rust，我们可以将其视为str等同于上面的第一行stack_string。String相当于第二行，heap_string. 虽然这有点过于简单化，但它是帮助我们理解 Rust 中的字符串的一个很好的模型。

4.1.2 有效使用字符串
大多数时候，在 Rust 中工作时，您将使用 aString或&str，但永远不会使用str。Rust标准库的不可变字符串函数是针对&str类型实现的，但可变函数只是针对String类型实现的。

无法str直接创建，只能借用一个引用。该&str类型充当方便的最小公分母，例如用作函数参数时，因为您始终可以借用Stringas &str。



让我们快速讨论一下静态生命周期：在 Rust 中，静态'static生命周期是一个特殊的生命周期说明符，它定义了一个在进程的整个生命周期内有效的引用（或借用变量）。在一些特殊情况下，您可能需要显式&'static str，但在实践中这种情况很少遇到。

&'static str和之间唯一真正的区别&str是，虽然 aString可以借用 as &str，但String绝不能借用 as &'static str，因为 String 的生命周期永远不会像进程一样长。当 aString超出范围时，它会与该Drop特征一起释放（我们将在第 8 章中更详细地探讨特征）。

在底层，aString实际上只是一个VecUTF-8 字符。我们将Vec在本章后面更详细地讨论。此外，astr只是 UTF-8 字符的切片，我们将在下一节中详细讨论切片。



str和之间的另一个区别String是String可以移动，而str不能移动。事实上，不可能拥有 类型的变量str，只能保存对 的引用str。为了说明这一点，请考虑以下示例：